<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Academic | Абдулфазов Мансур А.о.</title>
    <link>https://mabdulfazov.github.io/ru/tag/academic/</link>
      <atom:link href="https://mabdulfazov.github.io/ru/tag/academic/index.xml" rel="self" type="application/rss+xml" />
    <description>Academic</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>ru-ru</language><lastBuildDate>Fri, 27 May 2022 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://mabdulfazov.github.io/media/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url>
      <title>Academic</title>
      <link>https://mabdulfazov.github.io/ru/tag/academic/</link>
    </image>
    
    <item>
      <title>Языки программирования</title>
      <link>https://mabdulfazov.github.io/ru/post/clanguage/</link>
      <pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate>
      <guid>https://mabdulfazov.github.io/ru/post/clanguage/</guid>
      <description>&lt;h2 id=&#34;обзор&#34;&gt;Обзор&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Язык программирования — это любой набор правил, который преобразует строки или графические элементы программы в случае визуальных языков программирования в различные виды вывода машинного кода. Языки программирования — это один из видов компьютерных языков, которые используются в компьютерном программировании для реализации алгоритмов.&lt;/p&gt;
&lt;p&gt;Большинство языков программирования состоят из инструкций для компьютеров. Существуют программируемые машины, которые используют набор определенных инструкций, а не общие языки программирования. С начала 1800-х годов программы использовались для управления поведением таких машин, как жаккардовые ткацкие станки, музыкальные шкатулки и пианино. Программы для этих машин (такие как свитки пианино) не давали разного поведения в ответ на разные входные данные или условия.&lt;/p&gt;
&lt;p&gt;Созданы тысячи различных языков программирования, и с каждым годом их становится все больше. Многие языки программирования написаны в императивной форме (т. е. как последовательность выполняемых операций), в то время как другие языки используют декларативную форму (т. е. указывается желаемый результат, а не способ его достижения).&lt;/p&gt;
&lt;p&gt;Описание языка программирования обычно разбивается на два компонента: синтаксис (форма) и семантика (значение), которые обычно определяются формальным языком. Некоторые языки определяются документом спецификации (например, язык программирования C определяется стандартом ISO), в то время как другие языки (например, Perl) имеют доминирующую реализацию, которая рассматривается как эталон. В некоторых языках есть и то, и другое, при этом базовый язык определяется стандартом, а расширения, взятые из доминирующей реализации, являются общими.&lt;/p&gt;
&lt;p&gt;Теория языков программирования — это раздел компьютерных наук, который занимается проектированием, реализацией, анализом, характеристикой и классификацией языков программирования.&lt;/p&gt;
&lt;h2 id=&#34;определения&#34;&gt;Определения&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Язык программирования — это нотация для написания программ, которые являются спецификациями вычислений или алгоритмов. Некоторые авторы ограничивают термин «язык программирования» теми языками, которые могут выражать все возможные алгоритмы. Черты, которые часто считаются важными для того, что составляет язык программирования, включают:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Функция и цель&lt;/strong&gt;
Язык компьютерного программирования — это язык, используемый для написания компьютерных программ, в которых компьютер выполняет какие-то вычисления или алгоритмы и, возможно, управляет внешними устройствами, такими как принтеры, дисководы, роботы и т. д. Например, программы PostScript часто создаются другой программой для управления компьютерным принтером или дисплеем. В более общем смысле язык программирования может описывать вычисления на некоторой, возможно, абстрактной машине. Общепринято, что полная спецификация языка программирования включает описание, возможно идеализированное, машины или процессора для этого языка. В большинстве практических случаев язык программирования связан с компьютером; следовательно, языки программирования обычно определяются и изучаются таким образом. Языки программирования отличаются от естественных языков тем, что естественные языки используются только для взаимодействия между людьми, а языки программирования также позволяют людям передавать инструкции машинам.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Абстракции&lt;/strong&gt;
Языки программирования обычно содержат абстракции для определения и управления структурами данных или управления потоком выполнения. Практическая необходимость того, чтобы язык программирования поддерживал адекватные абстракции, выражается принципом абстракции. Этот принцип иногда формулируется как рекомендация программисту правильно использовать такие абстракции.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Выразительная сила&lt;/strong&gt;
Теория вычислений классифицирует языки по тем вычислениям, которые они способны выражать. Все полные по Тьюрингу языки могут реализовывать один и тот же набор алгоритмов. ANSI/ISO SQL-92 и Charity являются примерами языков, которые не являются полными по Тьюрингу, но их часто называют языками программирования.&lt;/p&gt;
&lt;p&gt;Языки разметки, такие как XML, HTML или troff, которые определяют структурированные данные, обычно не считаются языками программирования. Однако языки программирования могут использовать синтаксис совместно с языками разметки, если определена вычислительная семантика. XSLT, например, является полным по Тьюрингу языком, полностью использующим синтаксис XML. Более того, LaTeX, который в основном используется для структурирования документов, также содержит полное подмножество по Тьюрингу.&lt;/p&gt;
&lt;p&gt;Термин компьютерный язык иногда используется взаимозаменяемо с языком программирования. Однако использование обоих терминов варьируется у разных авторов, включая точную сферу применения каждого из них. Одно использование описывает языки программирования как подмножество компьютерных языков. Точно так же языки, используемые в вычислениях, которые имеют иную цель, чем выражение компьютерных программ, называются компьютерными языками общего назначения. Например, языки разметки иногда называют компьютерными языками, чтобы подчеркнуть, что они не предназначены для использования в программировании.&lt;/p&gt;
&lt;p&gt;В другом использовании языки программирования рассматриваются как теоретические конструкции для программирования абстрактных машин, а компьютерные языки - как их подмножество, которое работает на физических компьютерах с конечными аппаратными ресурсами. Джон К. Рейнольдс подчеркивает, что языки формальных спецификаций — это такие же языки программирования, как и языки, предназначенные для выполнения. Он также утверждает, что текстовые и даже графические форматы ввода, которые влияют на поведение компьютера, являются языками программирования, несмотря на то, что они обычно не являются полными по Тьюрингу, и отмечает, что незнание концепций языков программирования является причиной многих недостатков во входных форматах.&lt;/p&gt;
&lt;h2 id=&#34;история&#34;&gt;История&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Ранние разработки&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Самые ранние компьютеры, такие как Colossus, программировались без помощи хранимой программы, путем изменения их схем или настройки банков физических элементов управления.&lt;/p&gt;
&lt;p&gt;Чуть позже программы могли быть написаны на машинном языке, где программист записывает каждую инструкцию в числовой форме, которую аппаратное обеспечение может выполнять напрямую. Например, инструкция добавить значение в две ячейки памяти может состоять из 3 чисел: «код операции», который выбирает операцию «добавить», и двух ячеек памяти. Программы в десятичной или двоичной форме считывались с перфокарт, бумажной ленты, магнитной ленты или включались переключателями на передней панели компьютера. Позднее машинные языки были названы языками программирования первого поколения (1GL).&lt;/p&gt;
&lt;p&gt;Следующим шагом стала разработка так называемых языков программирования второго поколения (2GL) или языков ассемблера, которые по-прежнему были тесно связаны с архитектурой набора команд конкретного компьютера. Это помогло сделать программу более удобочитаемой и избавило программиста от утомительных и подверженных ошибкам вычислений адресов.&lt;/p&gt;
&lt;p&gt;Первые языки программирования высокого уровня, или языки программирования третьего поколения (3GL), были написаны в 1950-х годах. Первым языком программирования высокого уровня, предназначенным для компьютеров, был Plankalkül, разработанный для немецкого Z3 Конрадом Цузе в период с 1943 по 1945 год. Однако он не был реализован до 1998 и 2000 годов.&lt;/p&gt;
&lt;p&gt;Короткий код Джона Мочли, предложенный в 1949 году, был одним из первых языков высокого уровня, когда-либо разработанных для электронного компьютера. В отличие от машинного кода, операторы Short Code представляли собой математические выражения в понятной форме. Однако программу нужно было переводить в машинный код каждый раз, когда она запускалась, что делало процесс намного медленнее, чем запуск эквивалентного машинного кода.&lt;/p&gt;
&lt;p&gt;В Манчестерском университете Алик Гленни разработал Autocode в начале 1950-х годов. В качестве языка программирования он использовал компилятор для автоматического преобразования языка в машинный код. Первый код и компилятор были разработаны в 1952 году для компьютера Mark 1 в Манчестерском университете и считаются первым скомпилированным языком программирования высокого уровня.&lt;/p&gt;
&lt;p&gt;Второй автокод был разработан для Mark 1 Р. А. Брукером в 1954 году и назывался «Автокод Mark 1». Брукер также разработал автокод для Ferranti Mercury в 1950-х годах совместно с Манчестерским университетом. Версия для EDSAC 2 была разработана Д. Ф. Хартли из математической лаборатории Кембриджского университета в 1961 году. Известная как EDSAC 2 Autocode, она была прямым развитием Mercury Autocode, адаптированным к местным условиям, и была известна своей оптимизацией объектного кода и исходным языком. передовой для того времени диагностики. Современный, но отдельный поток разработки, Atlas Autocode был разработан для машины Atlas 1 Манчестерского университета.&lt;/p&gt;
&lt;p&gt;В 1954 году Джон Бэкус изобрел FORTRAN в IBM. Это был первый широко используемый язык программирования общего назначения высокого уровня, который имел функциональную реализацию, а не просто дизайн на бумаге. Он по-прежнему популярен для высокопроизводительных вычислений и используется в программах, которые оценивают и ранжируют самые быстрые суперкомпьютеры в мире.&lt;/p&gt;
&lt;p&gt;Еще один ранний язык программирования был разработан Грейс Хоппер в США и называется FLOW-MATIC. Он был разработан для UNIVAC I в компании Remington Rand в период с 1955 по 1959 год. Хоппер обнаружила, что клиентам, занимающимся обработкой бизнес-данных, не нравятся математические обозначения, и в начале 1955 года она и ее команда написали спецификацию для английского языка программирования и внедрили ее. прототип. Компилятор FLOW-MATIC стал общедоступным в начале 1958 года и был практически завершен в 1959 году. FLOW-MATIC оказал большое влияние на разработку COBOL, поскольку в то время фактически использовались только он и его прямой потомок AIMACO.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Уточнение&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Более широкое использование языков высокого уровня потребовало использования языков программирования низкого уровня или языков системного программирования. Эти языки в разной степени предоставляют возможности между языками ассемблера и языками высокого уровня. Их можно использовать для выполнения задач, которые требуют прямого доступа к аппаратным средствам, но при этом обеспечивают структуры управления более высокого уровня и проверку ошибок.&lt;/p&gt;
&lt;p&gt;Период с 1960-х до конца 1970-х годов принес развитие основных языковых парадигм, используемых в настоящее время:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;APL представил программирование массивов и повлиял на функциональное программирование.&lt;/li&gt;
&lt;li&gt;Алгол усовершенствовал как структурированное процедурное программирование, так и дисциплину спецификации языка; «Пересмотренный отчет об алгоритмическом языке ALGOL 60» стал образцом того, как были написаны более поздние спецификации языка.&lt;/li&gt;
&lt;li&gt;Lisp, реализованный в 1958 году, был первым динамически типизированным языком функционального программирования.&lt;/li&gt;
&lt;li&gt;В 1960-х Simula была первым языком, разработанным для поддержки объектно-ориентированного программирования; в середине 1970-х за ним последовал Smalltalk с первым «чисто» объектно-ориентированным языком.&lt;/li&gt;
&lt;li&gt;C был разработан между 1969 и 1973 годами как язык системного программирования для операционной системы Unix и остается популярным.&lt;/li&gt;
&lt;li&gt;Пролог, разработанный в 1972 году, был первым языком логического программирования.&lt;/li&gt;
&lt;li&gt;В 1978 году ML построила систему полиморфных типов поверх Lisp, став пионером в области функциональных языков программирования со статической типизацией.
Каждый из этих языков породил потомков, и большинство современных языков программирования насчитывают по крайней мере один из них в своей родословной.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В 1960-х и 1970-х годах также происходили серьезные споры о достоинствах структурного программирования и о том, следует ли разрабатывать языки программирования для его поддержки. Эдсгер Дейкстра в известном письме 1968 года, опубликованном в Communications of the ACM, утверждал, что операторы Goto следует исключить из всех языков программирования «высокого уровня».&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Консолидация и рост&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Подборка учебников по языкам программирования; лишь немногие из тысяч доступных.
1980-е были годами относительной консолидации. C++ сочетает в себе объектно-ориентированное и системное программирование. Правительство Соединенных Штатов стандартизировало Ada, язык системного программирования, производный от Pascal и предназначенный для использования оборонными подрядчиками. В Японии и других странах были потрачены огромные суммы на исследование так называемых языков «пятого поколения», которые включали конструкции логического программирования. Сообщество функциональных языков перешло к стандартизации ML и Lisp. Вместо того, чтобы изобретать новые парадигмы, все эти движения развивали идеи, изобретенные в предыдущие десятилетия.&lt;/p&gt;
&lt;p&gt;Одной из важных тенденций в разработке языков для программирования крупномасштабных систем в 1980-х годах было повышенное внимание к использованию модулей или крупномасштабных организационных единиц кода. Modula-2, Ada и ML разработали известные модульные системы в 1980-х годах, которые часто были привязаны к универсальным конструкциям программирования.&lt;/p&gt;
&lt;p&gt;Быстрый рост Интернета в середине 1990-х создал возможности для новых языков. Perl, изначально являвшийся инструментом сценариев Unix, впервые выпущенным в 1987 году, стал обычным явлением на динамических веб-сайтах. Java стала использоваться для программирования на стороне сервера, а виртуальные машины с байт-кодом снова стали популярными в коммерческих условиях благодаря их обещанию «написать один раз, запустить где угодно» (UCSD Pascal какое-то время был популярен в начале 1980-х годов). Эти разработки не были принципиально новыми; скорее, они были усовершенствованием многих существующих языков и парадигм (хотя их синтаксис часто основывался на семействе языков программирования C).&lt;/p&gt;
&lt;p&gt;Эволюция языков программирования продолжается как в промышленности, так и в исследованиях. Текущие направления включают проверку безопасности и надежности, новые виды модульности (примеси, делегаты, аспекты) и интеграцию с базами данных, например Microsoft LINQ.&lt;/p&gt;
&lt;p&gt;Языки программирования четвертого поколения (4GL) — это языки компьютерного программирования, цель которых — обеспечить более высокий уровень абстракции деталей внутреннего аппаратного обеспечения компьютера, чем 3GL. Языки программирования пятого поколения (5GL) — это языки программирования, основанные на решении задач с использованием ограничений, заданных для программы, а не с использованием алгоритма, написанного программистом.&lt;/p&gt;
&lt;h2 id=&#34;дизайн-и-реализация&#34;&gt;Дизайн и реализация&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Языки программирования имеют общие свойства с естественными языками, связанные с их назначением в качестве средств коммуникации, наличием синтаксической формы, отдельной от его семантики, и отображением языковых семей родственных языков, ответвляющихся друг от друга. Но как искусственные конструкции они фундаментально отличаются от языков, которые развились в процессе использования. Существенное отличие состоит в том, что язык программирования можно полностью описать и изучить целиком, поскольку он имеет точное и конечное определение. Напротив, естественные языки имеют изменяющиеся значения, придаваемые их пользователями в разных сообществах. Хотя сконструированные языки также являются искусственными языками, разработанными с нуля с определенной целью, им не хватает точного и полного семантического определения, которое есть у языка программирования.&lt;/p&gt;
&lt;p&gt;Многие языки программирования были разработаны с нуля, изменены для удовлетворения новых потребностей и объединены с другими языками. Многие со временем вышли из употребления. Хотя были попытки разработать один «универсальный» язык программирования, который служил бы всем целям, все они не были общепризнанными в качестве исполняющих эту роль. Необходимость в различных языках программирования возникает из-за разнообразия контекстов, в которых используются языки:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Программы варьируются от крошечных сценариев, написанных отдельными любителями, до огромных систем, написанных сотнями программистов.&lt;/li&gt;
&lt;li&gt;Опыт программистов варьируется от новичков, которым прежде всего нужна простота, до экспертов, которым может быть комфортно со значительной сложностью.&lt;/li&gt;
&lt;li&gt;Программы должны сочетать скорость, размер и простоту в системах от микроконтроллеров до суперкомпьютеров.&lt;/li&gt;
&lt;li&gt;Программы могут быть написаны один раз и не изменяться из поколения в поколение, или же они могут постоянно модифицироваться.&lt;/li&gt;
&lt;li&gt;У программистов могут быть просто разные вкусы: они могут привыкнуть обсуждать проблемы и выражать их на определенном языке.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Одной из общих тенденций в развитии языков программирования является расширение возможностей решения проблем с использованием более высокого уровня абстракции. Самые ранние языки программирования были очень тесно связаны с аппаратным обеспечением компьютера. По мере развития новых языков программирования были добавлены функции, которые позволяют программистам выражать идеи, более далекие от простого перевода в базовые аппаратные инструкции. Поскольку программисты менее привязаны к сложности компьютера, их программы могут выполнять больше вычислений с меньшими усилиями со стороны программиста. Это позволяет им писать больше функций в единицу времени.&lt;/p&gt;
&lt;p&gt;Программирование на естественном языке было предложено как способ устранить необходимость в специализированном языке программирования. Однако эта цель остается далекой, и ее преимущества открыты для обсуждения. Эдсгер В. Дейкстра занял позицию, согласно которой использование формального языка необходимо для предотвращения введения бессмысленных конструкций, и отверг программирование на естественном языке как «глупое». Алан Перлис также отверг эту идею. Гибридные подходы были применены в структурированном английском языке и SQL.&lt;/p&gt;
&lt;p&gt;Разработчики и пользователи языка должны создать ряд артефактов, которые управляют практикой программирования и делают ее возможной. Наиболее важными из этих артефактов являются спецификация и реализация языка.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Технические характеристики&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Спецификация языка программирования — это артефакт, который пользователи языка и разработчики могут использовать, чтобы договориться о том, является ли часть исходного кода действительной программой на этом языке, и если да, то каким должно быть его поведение.&lt;/p&gt;
&lt;p&gt;Спецификация языка программирования может принимать несколько форм, в том числе следующие:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Явное определение синтаксиса, статической семантики и семантики выполнения языка. Хотя синтаксис обычно задается с помощью формальной грамматики, семантические определения могут быть написаны на естественном языке (например, как в языке C) или формальной семантике (например, как в спецификациях Standard ML и Scheme).&lt;/li&gt;
&lt;li&gt;Описание поведения транслятора для языка (например, спецификации C++ и Fortran). Синтаксис и семантика языка должны быть выведены из этого описания, которое может быть написано на естественном или формальном языке.&lt;/li&gt;
&lt;li&gt;Реализация эталона или модели, иногда написанная на указанном языке (например, Prolog или ANSI REXX). Синтаксис и семантика языка явно выражены в поведении эталонной реализации.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Реализация&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Основная статья: Реализация языка программирования
Реализация языка программирования позволяет писать программы на этом языке и выполнять их на одной или нескольких конфигурациях аппаратного и программного обеспечения. В целом существует два подхода к реализации языка программирования: компиляция и интерпретация. Как правило, язык можно реализовать с использованием любой из этих техник.&lt;/p&gt;
&lt;p&gt;Вывод компилятора может выполняться аппаратным обеспечением или программой, называемой интерпретатором. В некоторых реализациях, использующих подход интерпретатора, нет четкой границы между компиляцией и интерпретацией. Например, некоторые реализации BASIC компилируют, а затем выполняют исходный код построчно.&lt;/p&gt;
&lt;p&gt;Программы, которые выполняются непосредственно на оборудовании, обычно работают намного быстрее, чем те, которые интерпретируются в программном обеспечении.&lt;/p&gt;
&lt;p&gt;Одним из методов повышения производительности интерпретируемых программ является своевременная компиляция. Здесь виртуальная машина непосредственно перед выполнением переводит блоки байт-кода, которые будут использоваться, в машинный код для прямого выполнения на оборудовании.&lt;/p&gt;
&lt;h2 id=&#34;проприетарные-языки&#34;&gt;Проприетарные языки&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Хотя большинство наиболее часто используемых языков программирования имеют полностью открытые спецификации и реализации, многие языки программирования существуют только как проприетарные языки программирования с реализацией, доступной только у одного поставщика, который может утверждать, что такой проприетарный язык является их интеллектуальной собственностью. Проприетарные языки программирования обычно являются предметно-ориентированными языками или внутренними языками сценариев для одного продукта; некоторые проприетарные языки используются только внутри поставщика, а другие доступны внешним пользователям.&lt;/p&gt;
&lt;p&gt;Некоторые языки программирования находятся на границе проприетарного и открытого; например, корпорация Oracle заявляет права собственности на некоторые аспекты языка программирования Java, а язык программирования Microsoft C#, который имеет открытые реализации большинства частей системы, также имеет среду Common Language Runtime (CLR) в качестве закрытой среды.&lt;/p&gt;
&lt;p&gt;Многие проприетарные языки широко используются, несмотря на их проприетарную природу; примеры включают MATLAB, VBScript и Wolfram Language. Некоторые языки могут переходить от закрытого к открытому; например, Erlang изначально был внутренним языком программирования Ericsson.&lt;/p&gt;
&lt;h2 id=&#34;использование&#34;&gt;Использование&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Были созданы тысячи различных языков программирования, в основном в вычислительной сфере. Отдельные программные проекты обычно используют пять или более языков программирования.&lt;/p&gt;
&lt;p&gt;Языки программирования отличаются от большинства других форм человеческого выражения тем, что требуют большей точности и полноты. При использовании естественного языка для общения с другими людьми люди-авторы и говорящие могут быть двусмысленными и делать небольшие ошибки, но при этом ожидать, что их намерения будут поняты. Однако, образно говоря, компьютеры «делают именно то, что им говорят», и не могут «понять», какой код намеревался написать программист. Комбинация определения языка, программы и входных данных программы должна полностью определять внешнее поведение, возникающее при выполнении программы в пределах области управления этой программы. С другой стороны, идеи об алгоритме могут быть переданы людям без точности, необходимой для выполнения, с помощью псевдокода, который чередует естественный язык с кодом, написанным на языке программирования.&lt;/p&gt;
&lt;p&gt;Язык программирования предоставляет структурированный механизм для определения фрагментов данных, а также операций или преобразований, которые могут выполняться автоматически с этими данными. Программист использует абстракции, присутствующие в языке, для представления понятий, связанных с вычислением. Эти концепции представлены в виде набора простейших доступных элементов (называемых примитивами). Программирование — это процесс, посредством которого программисты комбинируют эти примитивы для создания новых программ или адаптируют существующие для новых целей или меняющейся среды.&lt;/p&gt;
&lt;p&gt;Программы для компьютера могут выполняться в пакетном режиме без участия человека, или пользователь может вводить команды в интерактивном сеансе интерпретатора. В этом случае «команды» — это просто программы, выполнение которых связано друг с другом. Когда язык может выполнять свои команды через интерпретатор (такой как оболочка Unix или другой интерфейс командной строки) без компиляции, он называется языком сценариев.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Измерение использования языка&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Определить, какой язык программирования является наиболее широко используемым, сложно, поскольку определение использования зависит от контекста. Один язык может занимать большее количество часов программиста, другой — больше строк кода, а третий может потреблять больше всего процессорного времени. Некоторые языки очень популярны для определенных типов приложений. Например, COBOL по-прежнему эффективен в корпоративных центрах обработки данных, часто на больших мейнфреймах; Фортран в научных и инженерных приложениях; Ада в аэрокосмической, транспортной, военной сфере, приложениях реального времени и встроенных приложениях; и C во встроенных приложениях и операционных системах. Другие языки регулярно используются для написания самых разных приложений.&lt;/p&gt;
&lt;p&gt;Были предложены различные методы измерения популярности языка, каждый из которых имеет разную предвзятость в отношении того, что измеряется:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;подсчет количества объявлений о вакансиях, в которых упоминается язык&lt;/li&gt;
&lt;li&gt;количество проданных книг, обучающих или описывающих язык&lt;/li&gt;
&lt;li&gt;оценки количества существующих строк кода, написанного на языке, что может занижать оценки языков, которые не часто встречаются в общедоступных поисковых запросах.&lt;/li&gt;
&lt;li&gt;количество ссылок на язык (т. е. на название языка), найденных с помощью поисковой системы.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Объединив и усреднив информацию с различных интернет-сайтов, stackify.com сообщил о десяти самых популярных языках программирования (в порядке убывания общей популярности): Java, C, C++, Python, C#, JavaScript, VB .NET, R, PHP и МАТЛАБ.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Git</title>
      <link>https://mabdulfazov.github.io/ru/post/getting-started/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://mabdulfazov.github.io/ru/post/getting-started/</guid>
      <description>&lt;h2 id=&#34;обзор&#34;&gt;Обзор&lt;/h2&gt;
&lt;p&gt;Git — это программа для отслеживания изменений в любом наборе файлов, обычно используемая для координации работы программистов, совместно разрабатывающих исходный код во время разработки программного обеспечения. Его цели включают скорость, целостность данных и поддержку распределенных нелинейных рабочих процессов (тысячи параллельных ветвей, работающих в разных системах).&lt;/p&gt;
&lt;p&gt;Первоначально Git был создан Линусом Торвальдсом в 2005 году для разработки ядра Linux, а другие разработчики ядра внесли свой вклад в его первоначальную разработку. С 2005 года основным сопровождающим является Хунио Хамано. Как и в большинстве других распределенных систем управления версиями и в отличие от большинства клиент-серверных систем, каждый каталог Git на каждом компьютере представляет собой полноценный репозиторий с полной историей и полными возможностями отслеживания версий, независимо от доступа к сети или центрального сервера. бесплатное программное обеспечение с открытым исходным кодом, распространяемое только по лицензии GPL-2.0.&lt;/p&gt;
&lt;h2 id=&#34;история&#34;&gt;История&lt;/h2&gt;
&lt;p&gt;Разработка Git началась в апреле 2005 года, после того как многие разработчики ядра Linux отказались от доступа к BitKeeper, проприетарной системе управления исходным кодом (SCM), которую они использовали для поддержки проекта с 2002 года. Владелец авторских прав BitKeeper Ларри Маквой , отказалась от бесплатного использования продукта после того, как заявила, что Эндрю Триджелл создал SourcePuller путем обратного проектирования протоколов BitKeeper. Тот же самый инцидент подстегнул создание еще одной системы контроля версий, Mercurial.&lt;/p&gt;
&lt;p&gt;Линусу Торвальдсу нужна была распределенная система, которую он мог бы использовать как BitKeeper, но ни одна из доступных бесплатных систем не соответствовала его потребностям. Торвальдс привел пример системы управления исходным кодом, которой требуется 30 секунд, чтобы применить исправление и обновить все связанные метаданные, и отметил, что это не соответствует потребностям разработки ядра Linux, где синхронизация с другими сопровождающими может потребовать 250 таких действий за раз. однажды. В качестве критерия дизайна он указал, что исправление должно занимать не более трех секунд, и добавил еще три цели:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Возьмем Concurrent Versions System (CVS) в качестве примера того, что &lt;em&gt;нельзя&lt;/em&gt; делать; если сомневаетесь, примите прямо противоположное решение.&lt;/li&gt;
&lt;li&gt;Поддержка распределенного рабочего процесса, подобного BitKeeper.&lt;/li&gt;
&lt;li&gt;Включите очень надежные средства защиты от случайного или злонамеренного повреждения.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти критерии исключали все системы контроля версий, использовавшиеся в то время, поэтому сразу после разработки ядра Linux 2.6.12-rc2 Торвальдс решил написать свою собственную.&lt;/p&gt;
&lt;p&gt;Разработка Git началась 3 апреля 2005 года. Торвальдс объявил о проекте 6 апреля и на следующий день стал самостоятельным хостингом. Первое слияние нескольких филиалов состоялось 18 апреля. Торвальдс достиг поставленных целей; 29 апреля зарождающийся Git был протестирован с записью исправлений к дереву ядра Linux со скоростью 6,7 исправлений в секунду. 16 июня Git выпустил версию ядра 2.6.12.&lt;/p&gt;
&lt;p&gt;26 июля 2005 г. компания orvalds передала техническое обслуживание Хунио Хамано, основному участнику проекта. Хамано отвечал за выпуск 1.0 21 декабря 2005 г. и остается основным сопровождающим проекта.&lt;/p&gt;
&lt;h2 id=&#34;название&#34;&gt;Название&lt;/h2&gt;
&lt;p&gt;Торвальдс саркастически пошутил по поводу имени &lt;em&gt;git&lt;/em&gt; (что означает «неприятный человек» на британском английском сленге): «Я эгоистичный ублюдок и называю все свои проекты своим именем. Сначала «Linux», теперь «git». На справочной странице Git описывается как «тупой трекер контента». Файл readme с исходным кодом уточняется далее:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;git&amp;rdquo; может означать что угодно, в зависимости от вашего настроения.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Произвольная комбинация из трех букв, которая произносится и фактически не используется какой-либо общей командой UNIX. Тот факт, что это неправильное произношение слова «получить», может иметь значение, а может и не иметь.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Глупый. Презренный и презренный. Простой. Выбирайте из словаря сленга.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;«Глобальный информационный трекер»: у вас хорошее настроение, и это действительно работает на вас. Ангелы поют, и свет внезапно наполняет комнату.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;Чертов идиотский грузовик с дерьмом&amp;rdquo;: когда он ломается.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Git (основная реализация на C) в основном разработан для Linux, хотя он также поддерживает большинство основных операционных систем, включая BSD (DragonFly BSD, FreeBSD, NetBSD и OpenBSD), Solaris, macOS и Windows.&lt;/p&gt;
&lt;p&gt;Первый порт Git для Windows был в первую очередь фреймворком эмуляции Linux, на котором размещена версия Linux. При установке Git под Windows создается каталог Program Files с аналогичным названием, содержащий порт Mingw-w64 коллекции компиляторов GNU, Perl 5, MSYS2 (который сам является ответвлением Cygwin, Unix-подобной среды эмуляции для Windows) и различные другие порты или эмуляции Windows. утилит и библиотек Linux. В настоящее время собственные сборки Git для Windows распространяются в виде 32- и 64-разрядных установщиков. Официальный веб-сайт git в настоящее время поддерживает сборку Git для Windows, по-прежнему использующую среду MSYS2.&lt;/p&gt;
&lt;p&gt;JGit-реализация Git — это программная библиотека на чистом языке Java, предназначенная для встраивания в любое приложение Java. JGit используется в инструменте проверки кода Gerrit и в EGit, клиенте Git для Eclipse IDE.&lt;/p&gt;
&lt;p&gt;Go-git — это реализация Git с открытым исходным кодом, написанная на чистом Go. В настоящее время он используется для поддержки проектов в качестве интерфейса SQL для репозиториев кода Git и обеспечения шифрования для Git.&lt;/p&gt;
&lt;p&gt;Реализация Git в Dulwich — это чистый программный компонент Python для Python 2.7, 3.4 и 3.5.&lt;/p&gt;
&lt;p&gt;Реализация Git на libgit2 представляет собой программную библиотеку ANSI C без каких-либо других зависимостей, которую можно построить на нескольких платформах, включая Windows, Linux, macOS и BSD. Он имеет привязки для многих языков программирования, включая Ruby, Python и Haskell.&lt;/p&gt;
&lt;p&gt;JS-Git — это реализация JavaScript подмножества Git.&lt;/p&gt;
&lt;h2 id=&#34;соглашения&#34;&gt;Соглашения&lt;/h2&gt;
&lt;p&gt;Git не накладывает много ограничений на то, как его следует использовать, но некоторые соглашения приняты для организации истории, особенно те, которые требуют сотрудничества многих участников.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ветка &lt;em&gt;master&lt;/em&gt; создается по умолчанию с помощью &lt;em&gt;git init&lt;/em&gt; и часто используется как ветка, в которую объединяются другие изменения. Соответственно, имя вышестоящей удаленной ветки по умолчанию — &lt;em&gt;origin&lt;/em&gt;, поэтому имя удаленной ветки по умолчанию — &lt;em&gt;origin/master&lt;/em&gt;. Использование &lt;em&gt;master&lt;/em&gt; в качестве имени ветки по умолчанию не всегда верно. Репозитории, созданные в GitHub и GitLab, будут инициализированы с веткой &lt;em&gt;main&lt;/em&gt; вместо &lt;em&gt;master&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Отправленные коммиты обычно не должны быть перезаписаны, а скорее должны быть _revert_ed (коммит делается поверх, который отменяет изменения более раннего коммита). Это предотвращает недопустимость общих новых коммитов, основанных на общих коммитах, поскольку коммит, на котором они основаны, не существует на удаленном сервере. Если коммиты содержат конфиденциальную информацию, их следует удалить, что требует более сложной процедуры перезаписи истории.&lt;/li&gt;
&lt;li&gt;Рабочий процесс &lt;em&gt;git-flow&lt;/em&gt; и соглашения об именах часто используются для различения нестабильных историй конкретных функций (feature/*), нестабильных общих историй (develop), готовых к производству историй (main) и экстренных исправлений для выпущенных продуктов (hotfix).&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Pull-запросы&lt;/em&gt; не являются функцией git, но обычно предоставляются облачными сервисами git. Запрос на вытягивание — это запрос одного пользователя на слияние ветки его ветки репозитория с другим репозиторием, имеющим ту же историю (называется &lt;em&gt;upstream&lt;/em&gt; remote). Основная функция запроса на вытягивание ничем не отличается от функции администратора репозитория, извлекающего изменения из другого удаленного репозитория (репозиторий, который является источником запроса на вытягивание). Однако сам запрос на вытягивание представляет собой билет, управляемый хост-сервером, который инициирует сценарии для выполнения этих действий; это не функция git SCM.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>LaTeX</title>
      <link>https://mabdulfazov.github.io/ru/post/latex/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://mabdulfazov.github.io/ru/post/latex/</guid>
      <description>&lt;h2 id=&#34;обзор&#34;&gt;Обзор&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;LaTeX&lt;/strong&gt; — это программная система для подготовки документов. При написании писатель использует обычный текст, а не форматированный текст, который можно найти в текстовых процессорах «что видишь, то и получишь», таких как Microsoft Word, LibreOffice Writer и Apple Pages. Автор использует соглашения о тегах разметки, чтобы определить общую структуру документа, стилизовать текст по всему документу (например, выделить жирным шрифтом и курсивом), а также добавить цитаты и перекрестные ссылки. Дистрибутив TeX, такой как TeX Live или MiKTeX, используется для создания выходного файла (например, PDF или DVI), подходящего для печати или цифрового распространения.&lt;/p&gt;
&lt;p&gt;LaTeX широко используется в научных кругах для обмена и публикации научных документов во многих областях, включая математику, информатику, инженерию, физику, химию, экономику, лингвистику, количественную психологию, философию и политологию. Он также играет заметную роль в подготовке и публикации книг и статей, содержащих сложные многоязычные материалы, такие как санскрит и греческий. LaTeX использует программу набора текста TeX для форматирования своего вывода и сам написан на языке макросов TeX.&lt;/p&gt;
&lt;p&gt;LaTeX можно использовать как самостоятельную систему подготовки документов или как промежуточный формат. Например, в последней роли он иногда используется как часть конвейера для перевода DocBook и других форматов на основе XML в PDF. Система набора текста предлагает программируемые функции настольной издательской системы и широкие возможности для автоматизации большинства аспектов набора текста и настольной публикации, включая нумерацию и перекрестные ссылки на таблицы и рисунки, заголовки глав и разделов, включение графики, макет страницы, индексирование и библиографии.&lt;/p&gt;
&lt;p&gt;Как и TeX, LaTeX начинался как инструмент письма для математиков и специалистов по информатике, но даже с самого начала своего развития он также использовался учеными, которым нужно было писать документы, содержащие сложные математические выражения или нелатинские шрифты, такие как арабский. , деванагари и китайский.&lt;/p&gt;
&lt;p&gt;LaTeX предназначен для предоставления описательного языка разметки высокого уровня, который упрощает доступ к возможностям TeX для писателей. По сути, TeX обрабатывает макет, а LaTeX — контент для обработки документов. LaTeX включает в себя набор макросов TeX и программу для обработки документов LaTeX, и, поскольку простые команды форматирования TeX являются элементарными, он предоставляет авторам готовые команды для требований форматирования и макета, таких как заголовки глав, сноски, перекрестные ссылки и библиографии. .&lt;/p&gt;
&lt;p&gt;Первоначально LaTeX был написан в начале 1980-х годов Лесли Лэмпорт из SRI International. Текущая версия — LaTeX2e (стилизованная под LATEX2ε), выпущенная в 1994 году, но обновленная в 2020 году. LaTeX3 (LATEX3) находится в стадии длительной разработки с начала 1990-х годов. LaTeX является бесплатным программным обеспечением и распространяется под лицензией LaTeX Project Public License (LPPL).&lt;/p&gt;
&lt;h2 id=&#34;система-набора-текста&#34;&gt;Система набора текста&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;LaTeX пытается следовать философии дизайна, отделяя презентацию от контента, чтобы авторы могли сосредоточиться на содержании того, что они пишут, не обращая внимания одновременно на его внешний вид. При подготовке документа LaTeX автор указывает логическую структуру, используя простые знакомые понятия, такие как &lt;em&gt;глава&lt;/em&gt;, &lt;em&gt;раздел&lt;/em&gt;, &lt;em&gt;таблица&lt;/em&gt;, &lt;em&gt;рисунок&lt;/em&gt; и т. д., и позволяет системе LaTeX обрабатывать форматирование и расположение этих структур. В результате он поощряет отделение макета от содержимого, но при этом позволяет вносить коррективы вручную, когда это необходимо. Эта концепция аналогична механизму, с помощью которого многие текстовые процессоры позволяют определять стили глобально для всего документа, или использованию каскадных таблиц стилей для оформления HTML-документов.&lt;/p&gt;
&lt;p&gt;Система LaTeX — это язык разметки, который управляет набором текста и визуализацией и может быть произвольно расширен за счет использования базового макроязыка для разработки пользовательских макросов, таких как новые среды и команды. Такие макросы часто собираются в &lt;em&gt;пакеты&lt;/em&gt;, которые затем можно сделать доступными для решения некоторых конкретных задач набора текста, таких как форматирование сложных математических выражений или графики (например, использование среды &lt;code&gt;align&lt;/code&gt;, предоставляемой пакетом &lt;code&gt;amsmath&lt;/code&gt;, для создания согласованные уравнения).&lt;/p&gt;
&lt;p&gt;Чтобы создать документ в LaTeX, вы сначала пишете файл, скажем, &lt;code&gt;document.tex&lt;/code&gt;, используя предпочитаемый вами текстовый редактор. Затем вы передаете свой файл &lt;code&gt;document.tex&lt;/code&gt; в качестве входных данных для программы TeX (с загруженными макросами LaTeX), которая предлагает TeX записать файл, подходящий для просмотра на экране или печати. Этот цикл «запись-формат-предварительный просмотр» является одним из основных отличий работы с LaTeX от стиля редактирования документов «что видишь, то и получаешь» (WYSIWYG). Это похоже на известный программистам цикл код-компиляция-выполнение. Сегодня многие программы редактирования, поддерживающие LaTeX, делают этот цикл простым нажатием одной клавиши, при этом предварительный просмотр вывода отображается на экране рядом с окном ввода. Некоторые онлайн-редакторы LaTeX даже автоматически обновляют предварительный просмотр, в то время как другие онлайн-инструменты обеспечивают поэтапное редактирование на месте, смешанное с предварительным просмотром в оптимизированном едином окне.&lt;/p&gt;
&lt;h2 id=&#34;произношение-и-написание-latex&#34;&gt;Произношение и написание «LaTeX»&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;Символы «T», «E» и «X» в названии произошли от греческих заглавных букв tau, epsilon и chi, так как название TeX происходит от древнегреческого: τέχνη («навык», «искусство»). , «техника»); по этой причине создатель TeX Дональд Кнут продвигает его произношение как / tɛx / (&lt;em&gt;tekh&lt;/em&gt;) (то есть с глухим велярным фрикативом, как в новогреческом, похожем на ch в слове loch). Лэмпорт отмечает, что «TeX обычно произносится как &lt;em&gt;tech&lt;/em&gt;, что делает логичным выбор &lt;em&gt;lah&lt;/em&gt;-tech, lah-&lt;em&gt;tech&lt;/em&gt; и &lt;em&gt;lay&lt;/em&gt;-tech; но язык не всегда логичен, поэтому &lt;em&gt;lay-tecks&lt;/em&gt; также возможен».&lt;/p&gt;
&lt;p&gt;Название традиционно печатается бегущим текстом со специальным типографским логотипом: LATEX. В средствах массовой информации, где логотип не может быть точно воспроизведен в бегущем тексте, слову обычно присваивается уникальная заглавная буква &lt;em&gt;LaTeX&lt;/em&gt;. Кроме того, логотипы TeX, LaTeX и XeTeX также могут быть отображены с помощью чистого CSS и XHTML для использования в графических веб-браузерах — в соответствии со спецификациями внутреннего макроса &lt;code&gt;\LaTeX&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;сопутствующее-программное-обеспечение&#34;&gt;Сопутствующее программное обеспечение&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;В качестве пакета макросов LaTeX предоставляет набор макросов для интерпретации TeX. Существует много других пакетов макросов для TeX, включая Plain TeX, GNU Texinfo, AMSTeX и ConTeXt.&lt;/p&gt;
&lt;p&gt;Когда TeX «компилирует» документ, он следует (с точки зрения пользователя) следующей последовательности обработки: Макросы → TeX → Драйвер → Вывод. Различные реализации каждого из этих шагов обычно доступны в дистрибутивах TeX. Традиционный TeX выводит файл DVI, который обычно преобразуется в файл PostScript. Совсем недавно Hàn Thế Thành и другие написали новую реализацию TeX под названием pdfTeX, которая также выводит в PDF и использует функции, доступные в этом формате. Механизм XeTeX, разработанный Джонатаном Кью, с другой стороны, объединяет современные технологии шрифтов и Unicode с TeX.&lt;/p&gt;
&lt;p&gt;Шрифтом по умолчанию для LaTeX является Knuth&amp;rsquo;s Computer Modern, который придает документам по умолчанию, созданным с помощью LaTeX, такой же отличительный вид, как и созданным с помощью простого TeX. XeTeX позволяет использовать шрифты OpenType и TrueType (то есть контурные) для выходных файлов.&lt;/p&gt;
&lt;p&gt;Существует также множество редакторов для LaTeX, некоторые из которых являются автономными, основанными на исходном коде, а другие — онлайновыми, частично основанными на WYSIWYG. Подробнее см. в разделе Сравнение редакторов TeX.&lt;/p&gt;
&lt;h2 id=&#34;история&#34;&gt;История&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;LaTeX был создан в начале 1980-х Лесли Лэмпортом, когда он работал в SRI. Ему нужно было написать макросы TeX для собственного использования, и он подумал, что, приложив немного дополнительных усилий, он сможет сделать общий пакет пригодным для использования другими. Питер Гордон, редактор Addison-Wesley, убедил его написать руководство пользователя LaTeX для публикации (Лэмпорт изначально скептически относился к тому, что кто-то будет платить за это деньги); он вышел в 1986 году и был продан сотнями тысяч копий. Тем временем Лэмпорт выпустил версии своих макросов LaTeX в 1984 и 1985 годах. 21 августа 1989 года на собрании группы пользователей TeX (TUG) в Стэнфорде Лэмпорт согласился передать обслуживание и разработку LaTeX Фрэнку Миттельбаху. Миттельбах вместе с Крисом Роули и Райнером Шопфом сформировал команду LaTeX3; в 1994 году они выпустили LaTeX2e, текущую стандартную версию. С тех пор сам LaTeX3 был отменен, а функции версии, предназначенные для этой версии, были перенесены в LaTeX 2e с 2018 года.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Система оправления пакетами Portage</title>
      <link>https://mabdulfazov.github.io/ru/post/portage/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://mabdulfazov.github.io/ru/post/portage/</guid>
      <description>&lt;h2 id=&#34;обзор&#34;&gt;Обзор&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Доступ к Portage&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Графический интерфейс Porthole.
Portage похож на управление пакетами в стиле BSD, известное как порты, и изначально был разработан с учетом портов FreeBSD. Portage написан на языке программирования Python и является основной утилитой, определяющей Gentoo. Хотя сама система известна как Portage, она состоит из двух основных частей: системы ebuild и emerge. Система ebuild берет на себя фактическую работу по сборке и установке пакетов, тогда как emerge предоставляет интерфейс для ebuild: управление репозиторием ebuild, разрешение зависимостей и подобные проблемы. (Поэтому эти два параметра имеют примерно такое же отношение, как rpm к yum или dpkg к APT.)&lt;/p&gt;
&lt;p&gt;Графический интерфейс Portage на основе GTK+ доступен для работы с Portage. Существует также графический интерфейс Himerge, что означает «интерфейс Haskell для eMerge».&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Предоставленные функции&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Portage характеризуется своей основной функцией: компиляцией из исходного кода пакетов, которые пользователь хочет установить. При этом он позволяет настраивать параметры компилятора и целевого приложения в соответствии со спецификациями системы и собственными пожеланиями пользователя. Функции, связанные с управлением системой, включают в себя: возможность параллельной установки версий пакетов, отслеживание зависимостей между пакетами, управление базой данных установленных пакетов, предоставление локального репозитория ebuild-файлов и синхронизацию локального дерева Portage с удаленными репозиториями. Функциональные возможности, связанные с установкой отдельных пакетов, включают: указание параметров компиляции для целевой машины и выбор компонентов пакета.&lt;/p&gt;
&lt;p&gt;Portage различает три уровня стабильности в ebuild-файлах: стабильный (например, программное обеспечение работает, как задумано, без известных проблем с безопасностью на момент выпуска), замаскированный по ключевому слову (в основном для пакетов, которые не были достаточно протестированы на целевой архитектуре системы, чтобы их можно было рассматривать). стабильный) и жестко замаскированные (сломанные или очень небезопасные) пакеты.&lt;/p&gt;
&lt;h2 id=&#34;функции&#34;&gt;Функции&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Появляться&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Отключение файлового менеджера SpaceFM
Инструмент командной строки emerge является сердцем Portage. Команда настраивается с помощью множества параметров и модификаторов. Инструмент emerge — самая важная утилита для доступа к функциям Portage из командной строки.&lt;/p&gt;
&lt;p&gt;Программа вычисляет и управляет зависимостями, выполняет ебилды и поддерживает локальное дерево портежей и базу данных установленных пакетов. Параметры компиляции, используемые ebuild-файлами, можно изменить с помощью переменной среды CFLAGS в зависимости от характеристик отдельного компьютера и желания пользователя оптимизировать его. Утилита emerge запускает ебилды в песочнице. Таким образом, система защищена от программного обеспечения, запускаемого ebuild-файлом, а результирующие двоичные файлы объединяются только после успешной сборки и установки в песочнице.&lt;/p&gt;
&lt;p&gt;То, что emerge устанавливает в качестве зависимостей, зависит от настроек USE-флагов. Они решают, какие дополнительные функции будут включены при установке или обновлении приложения. Команду emerge также можно использовать для загрузки и установки предварительно скомпилированных двоичных файлов.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;USE-флаги&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Portage во время обновления системы
Система Portage предлагает использование «USE-флагов», которые позволяют пользователям указывать, какие функции программного обеспечения они хотели бы включить (или исключить) при создании пакетов. Например, есть флаг USE для включения поддержки DVD, если она доступна, в пакеты, скомпилированные с включенным флагом. USE-флаги влияют на то, какие зависимости требуются, как правило, на то, какие дополнительные функции будут встроены в данную программу при ее компиляции. Например, в пакетах, использующих скрипт configure, функция флага USE будет преобразована в ./configure &amp;ndash;with-feature.&lt;/p&gt;
&lt;p&gt;Спецификация USE-флагов — это обычный способ настройки программ в Gentoo. USE-флаги можно устанавливать вручную или с помощью удобных инструментов, таких как ufed (редактор USE-флагов), в котором перечислены флаги вместе с их описанием. Список доступных USE-флагов доступен на веб-сайте Gentoo в списке USE-флагов.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Появляться&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Отключение файлового менеджера SpaceFM
Инструмент командной строки emerge является сердцем Portage. Команда настраивается с помощью множества параметров и модификаторов. Инструмент emerge — самая важная утилита для доступа к функциям Portage из командной строки.&lt;/p&gt;
&lt;p&gt;Программа вычисляет и управляет зависимостями, выполняет ебилды и поддерживает локальное дерево портежей и базу данных установленных пакетов. Параметры компиляции, используемые ebuild-файлами, можно изменить с помощью переменной среды CFLAGS в зависимости от характеристик отдельного компьютера и желания пользователя оптимизировать его. Утилита emerge запускает ебилды в песочнице. Таким образом, система защищена от программного обеспечения, запускаемого ebuild-файлом, а результирующие двоичные файлы объединяются только после успешной сборки и установки в песочнице.&lt;/p&gt;
&lt;p&gt;То, что emerge устанавливает в качестве зависимостей, зависит от настроек USE-флагов. Они решают, какие дополнительные функции будут включены при установке или обновлении приложения. Команду emerge также можно использовать для загрузки и установки предварительно скомпилированных двоичных файлов.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;USE-флаги&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Portage во время обновления системы
Система Portage предлагает использование «USE-флагов», которые позволяют пользователям указывать, какие функции программного обеспечения они хотели бы включить (или исключить) при создании пакетов. Например, есть флаг USE для включения поддержки DVD, если она доступна, в пакеты, скомпилированные с включенным флагом. USE-флаги влияют на то, какие зависимости требуются, как правило, на то, какие дополнительные функции будут встроены в данную программу при ее компиляции. Например, в пакетах, использующих скрипт configure, функция флага USE будет преобразована в ./configure &amp;ndash;with-feature.&lt;/p&gt;
&lt;p&gt;Спецификация USE-флагов — это обычный способ настройки программ в Gentoo. USE-флаги можно устанавливать вручную или с помощью удобных инструментов, таких как ufed (редактор USE-флагов), в котором перечислены флаги вместе с их описанием. Список доступных USE-флагов доступен на веб-сайте Gentoo в списке USE-флагов.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;сборка&lt;/strong&gt;
По умолчанию Gentoo не использует бинарные пакеты, как это делают другие системы управления пакетами (например, pacman или apt), вместо этого используя формат, известный как ebuild. В то время как двоичные файлы RPM представляют собой предварительно скомпилированные двоичные файлы, ebuild-файлы представляют собой сценарии оболочки с переменными и функциями, которые содержат описание программного обеспечения и инструкции о том, как его получить, настроить, скомпилировать и установить, более близкие (но более мощные, чем) файлы . spec-файлы, распространяемые в пакетах SRPM.[8] Доступно более 19 000 ebuild-файлов, большинство из которых распространяется зеркалами Gentoo. Новые и обновленные ebuild-файлы можно получить, синхронизировав локальный репозиторий ebuild-файлов с зеркалами. Это делается с помощью команды emerge &amp;ndash;sync. Исторически сложилось так, что Gentoo предоставляет предварительно скомпилированные двоичные пакеты для многих распространенных программ, особенно для тех, которые требуют длительной компиляции, таких как Mozilla Firefox и OpenOffice.org. Они по-прежнему устанавливаются с помощью emerge, просто добавляя «-bin» к имени пакета, чтобы вместо этого установить двоичную версию.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Двоичные пакеты&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Gentoo имеет бинарный формат упаковки, который представляет собой файл .tbz2 (tar со сжатием bzip2) с дополнительными метаданными. Эта функция позволяет собирать бинарные пакеты на одной системе (используя buildpkg или quickpkg Portage) с последующей быстрой установкой на других, идентичных системах (с помощью getbinpkg Portage или emerge -K). Дополнительные сведения см. в разделе Возможности Portage в Руководстве по Gentoo Linux.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Маскировка&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Маскировка — это то, как Gentoo определяет, какие пакеты подходят для системы. Ebuilds, предназначенные для различных архитектур или экспериментального программного обеспечения, обычно маскируются таким образом, что стабильная система не может установить их без вмешательства пользователя.&lt;/p&gt;
&lt;p&gt;Пакеты, которые обычно просто требуют некоторого тестирования, но часто работают нормально, называются замаскированными ключевыми словами (т. е. они доступны для систем с записью ACCEPT_KEYWORDS в make.conf, начинающейся с символа ~, например, ~x86, ~amd64, ~ppc). Стандартный способ разоблачить отдельный пакет, замаскированный ключевым словом, — добавить файл с полным именем пакета и ключевым словом в /etc/portage/package.accept_keywords/. Пользователи также могут создавать здесь подкаталоги, что позволяет организовать их по своему усмотрению. Например, если замаскированный пакет имеет несколько замаскированных зависимостей, пользователь может создать каталог с именем исходного замаскированного пакета и поместить все файлы масок для пакета и его зависимостей в этот каталог. Эта схема заменяет старую схему использования /etc/portage/package.accept_keywords в виде списка текстовых файлов.&lt;/p&gt;
&lt;p&gt;Пакеты с известными проблемами или не считающиеся достаточно зрелыми, чтобы быть кандидатами на стабильную версию, жестко маскируются одним из различных файлов package.mask в /usr/portage/profiles, и такие записи обычно сопровождаются комментариями разработчиков, объясняющими причину маска.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
